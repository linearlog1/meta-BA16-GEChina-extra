From d3f333f3beef9a9ccbb3667cf8ffd34f57f580f8 Mon Sep 17 00:00:00 2001
From: Akshay Bhat <akshay.bhat@timesys.com>
Date: Tue, 5 Jul 2016 17:50:52 -0400
Subject: [PATCH] arm: imx: Add support for Advantech DMS-BA16 board

Add support for Advantech DMS-BA16 board. The board is based on Advantech
BA16 module which has a i.MX6D processor. The board supports:
 - FEC Ethernet
 - USB Ports
 - SDHC and MMC boot
 - SPI NOR
 - LVDS and HDMI display

Basic information about the module:
 - Module manufacturer: Advantech
 - CPU: Freescale ARM Cortex-A9 i.MX6D
 - SPECS:
     Up to 2GB Onboard DDR3 Memory;
     Up to 16GB Onboard eMMC NAND Flash
     Supports OpenGL ES 2.0 and OpenVG 1.1
     HDMI, 24-bit LVDS
     1x UART, 2x I2C, 8x GPIO,
     4x Host USB 2.0 port, 1x USB OTG port,
     1x micro SD (SDHC),1x SDIO, 1x SATA II,
     1x 10/100/1000 Mbps Ethernet, 1x PCIe X1 Gen2

Signed-off-by: Akshay Bhat <akshay.bhat@timesys.com>
Cc: u-boot@lists.denx.de
Cc: sbabic@denx.de
---
 arch/arm/cpu/armv7/mx6/Kconfig       |   5 +
 board/advantech/dms-ba16/Kconfig     |  27 ++
 board/advantech/dms-ba16/MAINTAINERS |   8 +
 board/advantech/dms-ba16/Makefile    |   8 +
 board/advantech/dms-ba16/ddr_1g.cfg  | 206 +++++++++++++
 board/advantech/dms-ba16/ddr_2g.cfg  | 151 +++++++++
 board/advantech/dms-ba16/dms-ba16.c  | 571 +++++++++++++++++++++++++++++++++++
 configs/dms-ba16-1g_defconfig        |  27 ++
 configs/dms-ba16_defconfig           |  26 ++
 include/configs/advantech_dms-ba16.h | 329 ++++++++++++++++++++
 10 files changed, 1358 insertions(+)
 create mode 100644 board/advantech/dms-ba16/Kconfig
 create mode 100644 board/advantech/dms-ba16/MAINTAINERS
 create mode 100644 board/advantech/dms-ba16/Makefile
 create mode 100644 board/advantech/dms-ba16/ddr_1g.cfg
 create mode 100644 board/advantech/dms-ba16/ddr_2g.cfg
 create mode 100644 board/advantech/dms-ba16/dms-ba16.c
 create mode 100644 configs/dms-ba16-1g_defconfig
 create mode 100644 configs/dms-ba16_defconfig
 create mode 100644 include/configs/advantech_dms-ba16.h

diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index 663f970..1e4a1cb 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -35,6 +35,10 @@ choice
 	prompt "MX6 board select"
 	optional
 
+config TARGET_ADVANTECH_DMS_BA16
+	bool "Advantech dms-ba16"
+	select MX6Q
+
 config TARGET_ARISTAINETOS
 	bool "aristainetos"
 
@@ -184,6 +188,7 @@ config SYS_SOC
 	default "mx6"
 
 source "board/ge/bx50v3/Kconfig"
+source "board/advantech/dms-ba16/Kconfig"
 source "board/aristainetos/Kconfig"
 source "board/bachmann/ot1200/Kconfig"
 source "board/barco/platinum/Kconfig"
diff --git a/board/advantech/dms-ba16/Kconfig b/board/advantech/dms-ba16/Kconfig
new file mode 100644
index 0000000..cbc803f
--- /dev/null
+++ b/board/advantech/dms-ba16/Kconfig
@@ -0,0 +1,27 @@
+choice
+        prompt "DDR Size"
+	default SYS_DDR_2G
+
+config SYS_DDR_1G
+	bool "1GiB"
+
+config SYS_DDR_2G
+	bool "2GiB"
+
+endchoice
+
+config IMX_CONFIG
+	default "board/advantech/dms-ba16/ddr_2g.cfg" if SYS_DDR_2G
+	default "board/advantech/dms-ba16/ddr_1g.cfg" if SYS_DDR_1G
+
+config SYS_BOARD
+	default "dms-ba16"
+
+config SYS_VENDOR
+	default "advantech"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "advantech_dms-ba16"
diff --git a/board/advantech/dms-ba16/MAINTAINERS b/board/advantech/dms-ba16/MAINTAINERS
new file mode 100644
index 0000000..e8ea3dd
--- /dev/null
+++ b/board/advantech/dms-ba16/MAINTAINERS
@@ -0,0 +1,8 @@
+ADVANTECH_DMS-BA16 BOARD
+M:	Akshay Bhat <akshaybhat@timesys.com>
+M:	Ken Lin <Ken.Lin@advantech.com.tw>
+S:	Maintained
+F:	board/advantech/dms-ba16/
+F:	include/configs/advantech_dms-ba16.h
+F:	configs/dms-ba16_defconfig
+F:	configs/dms-ba16-1g_defconfig
diff --git a/board/advantech/dms-ba16/Makefile b/board/advantech/dms-ba16/Makefile
new file mode 100644
index 0000000..ec9aaa8
--- /dev/null
+++ b/board/advantech/dms-ba16/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright 2016 Timesys Corporation
+# Copyright 2016 Advantech Corporation
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := dms-ba16.o
diff --git a/board/advantech/dms-ba16/ddr_1g.cfg b/board/advantech/dms-ba16/ddr_1g.cfg
new file mode 100644
index 0000000..a470f48
--- /dev/null
+++ b/board/advantech/dms-ba16/ddr_1g.cfg
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+
+IMAGE_VERSION 2
+BOOT_FROM sd
+
+//*================================================================================================
+// Enable all clocks (they are disabled by ROM code)
+//*================================================================================================
+DATA 4 0x020c4068  0xffffffff
+DATA 4 0x020c406c  0xffffffff
+DATA 4 0x020c4070  0xffffffff
+DATA 4 0x020c4074  0xffffffff
+DATA 4 0x020c4078  0xffffffff
+DATA 4 0x020c407c  0xffffffff
+DATA 4 0x020c4080  0xffffffff
+DATA 4 0x020c4084  0xffffffff
+
+//######################################################
+// IOMUX
+//######################################################
+
+//DDR IO TYPE:
+DATA 4 0x020e0798  0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL11
+DATA 4 0x020e0758  0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE0 , Pull disabled for all, except DQS.
+
+//CLOCK:
+DATA 4 0x020e0588  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE101, DDR_INPUT0, HYS0
+DATA 4 0x020e0594  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE101, DDR_INPUT0, HYS0
+
+//ADDRESS:
+DATA 4 0x020e056c  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e0578  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e074c  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE110
+
+//CONTROL:
+DATA 4 0x020e057c  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE110, DDR_INPUT1, HYS0, DDR_SEL00
+DATA 4 0x020e058c  0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+DATA 4 0x020e059c  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4 0x020e05a0  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4 0x020e078c  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE110
+
+//DATA STROBE:
+DATA 4 0x020e0750  0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT1
+DATA 4 0x020e05a8  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE110
+DATA 4 0x020e05b0  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE110
+DATA 4 0x020e0524  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE110
+DATA 4 0x020e051c  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE110
+DATA 4 0x020e0518  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE110
+DATA 4 0x020e050c  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE110
+DATA 4 0x020e05b8  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE110
+DATA 4 0x020e05c0  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE110
+
+//DATA:
+DATA 4 0x020e0774  0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+DATA 4 0x020e0784  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE110
+DATA 4 0x020e0788  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE110
+DATA 4 0x020e0794  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE110
+DATA 4 0x020e079c  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE110
+DATA 4 0x020e07a0  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE110
+DATA 4 0x020e07a4  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE110
+DATA 4 0x020e07a8  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE110
+DATA 4 0x020e0748  0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE110
+DATA 4 0x020e05ac  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e05b4  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e0528  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e0520  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e0514  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e0510  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e05bc  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE110, DDR_INPUT1, HYS0
+DATA 4 0x020e05c4  0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE110, DDR_INPUT1, HYS0
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+DATA 4 0x021b0800  0xa1390003      // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+DATA 4 0x021b080c  0x001F001F
+DATA 4 0x021b0810  0x001F001F
+DATA 4 0x021b480c  0x001F001F
+DATA 4 0x021b4810  0x001F001F
+
+//DQS gating, read delay, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board
+//and replace following delay values accordingly:
+
+//Read DQS Gating calibration
+DATA 4 0x021b083c  0x43480350
+DATA 4 0x021b0840  0x033C0340
+DATA 4 0x021b483c  0x43480350
+DATA 4 0x021b4840  0x03340314
+
+//Read calibration
+DATA 4 0x021b0848  0x382E2C32
+DATA 4 0x021b4848  0x38363044
+
+//Write calibration
+DATA 4 0x021b0850  0x3A38403A
+DATA 4 0x021b4850  0x4432483E
+
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):
+DATA 4 0x021b081c  0x33333333      // DDR_PHY_P0_MPREDQBY0DL3
+DATA 4 0x021b0820  0x33333333      // DDR_PHY_P0_MPREDQBY1DL3
+DATA 4 0x021b0824  0x33333333      // DDR_PHY_P0_MPREDQBY2DL3
+DATA 4 0x021b0828  0x33333333      // DDR_PHY_P0_MPREDQBY3DL3
+DATA 4 0x021b481c  0x33333333      // DDR_PHY_P1_MPREDQBY0DL3
+DATA 4 0x021b4820  0x33333333      // DDR_PHY_P1_MPREDQBY1DL3
+DATA 4 0x021b4824  0x33333333      // DDR_PHY_P1_MPREDQBY2DL3
+DATA 4 0x021b4828  0x33333333      // DDR_PHY_P1_MPREDQBY3DL3
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+DATA 4 0x021b08b8  0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4 0x021b48b8  0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+//528MHz in DDR3, 64-bit mode, only MMDC0 is initiated:
+DATA 4 0x021b0004  0x00020036      // MMDC0_MDPDC see spread sheet for timings
+DATA 4 0x021b0008  0x09444040      // MMDC0_MDOTC see spread sheet for timings
+DATA 4 0x021b000c  0x555A79A5      // MMDC0_MDCFG0 see spread sheet for timings. CL8
+DATA 4 0x021b0010  0xDB538E64      // MMDC0_MDCFG1 see spread sheet for timings
+DATA 4 0x021b0014  0x01ff00db      // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+DATA 4 0x021b0018  0x00001740      // MMDC0_MDMISC, RALAT0x5
+//MDMISC: RALAT kept to the high level of 5.
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits:
+//a. better operation at low frequency
+//b. Small performence improvment
+
+DATA 4 0x021b001c  0x00008000      // MMDC0_MDSCR
+DATA 4 0x021b002c  0x000026d2      // MMDC0_MDRWD
+DATA 4 0x021b0030  0x005a1023      // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck
+DATA 4 0x021b0040  0x00000027      // CS0_END - 0x4fffffff
+DATA 4 0x021b0000  0x831a0000      // MMDC0_MDCTL - row - 14bits; col  10bits; burst length 8; 64-bit data bus
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M , but fit wide range of other DDR3 devices
+//MR2:
+DATA 4 0x021b001c  0x04088032      // MMDC0_MDSCR
+DATA 4 0x021b001c  0x0408803a      // MMDC0_MDSCR
+//MR3:
+DATA 4 0x021b001c  0x00008033      // MMDC0_MDSCR
+DATA 4 0x021b001c  0x0000803b      // MMDC0_MDSCR
+//MR1:
+DATA 4 0x021b001c  0x00048031      // MMDC0_MDSCR
+DATA 4 0x021b001c  0x00048039      // MMDC0_MDSCR
+//MR0:
+DATA 4 0x021b001c  0x09408030      // MMDC0_MDSCR,
+DATA 4 0x021b001c  0x09408038      // MMDC0_MDSCR,
+
+//DDR device ZQ calibration:
+DATA 4 0x021b001c  0x04008040      // MMDC0_MDSCR,
+DATA 4 0x021b001c  0x04008048      // MMDC0_MDSCR
+//######################################################
+//final DDR setup, before operation start:
+DATA 4 0x021b0020  0x00005800      // MMDC0_MDREF, enable auto refresh, set refresh rate.
+
+//Following ODT setup (0x11117) represents(along with obove DDR device configs) : i.mx_ODTDDR_device_ODT120OHm.
+//User might to also interested in trying the value of 0x00000007,which represents: i.mx_ODT disabled, DDR_device_ODT120Ohm.
+//0x00000007 saves more power, and seen to run very well with Freescale RDKs. Still, running with no ODT has it's implications
+// of signal integrity and should be carefully simulated during board design.
+
+DATA 4 0x021b0818  0x00033337      // DDR_PHY_P0_MPODTCTRL, ODT enable
+DATA 4 0x021b4818  0x00033337      // DDR_PHY_P1_MPODTCTRL
+DATA 4 0x021b0004  0x00025576      // MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+DATA 4 0x021b0404  0x00011006      //MMDC0_MAPSR ADOPT power down enabled
+DATA 4 0x021b001c  0x00000000      // MMDC0_MDSCR
+
+/* set the default clock gate to save power */
+DATA 4  0x020c4068  0x00C03F3F
+DATA 4  0x020c406c  0x0030FC03
+DATA 4  0x020c4070  0x0FFFC000
+DATA 4  0x020c4074  0x3FF00000
+DATA 4  0x020c4078  0x00FFF300
+DATA 4  0x020c407c  0x0F0000C3
+DATA 4  0x020c4080  0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4  0x020e0010  0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4  0x020e0018  0x007F007F
+DATA 4  0x020e001c  0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  1    --> CKO1 enabled
+ * cko1_div 111  --> divide by 8
+ * cko1_sel 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 132/8 16.5 MHz
+ */
+DATA 4  0x020c4060  0x000000fb
diff --git a/board/advantech/dms-ba16/ddr_2g.cfg b/board/advantech/dms-ba16/ddr_2g.cfg
new file mode 100644
index 0000000..de88769
--- /dev/null
+++ b/board/advantech/dms-ba16/ddr_2g.cfg
@@ -0,0 +1,151 @@
+/*
+ *
+ * Copyright 2015 Timesys Corporation.
+ * Copyright 2015 General Electric Company
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+IMAGE_VERSION 2
+BOOT_FROM sd
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* DDR IO */
+DATA 4, MX6_IOM_GRP_DDR_TYPE,	0x000c0000
+DATA 4, MX6_IOM_GRP_DDRPKE,	0x00000000
+DATA 4, MX6_IOM_DRAM_SDCLK_0,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDCLK_1,	0x00000030
+DATA 4, MX6_IOM_DRAM_CAS,	0x00000030
+DATA 4, MX6_IOM_DRAM_RAS,	0x00000030
+DATA 4, MX6_IOM_GRP_ADDDS,	0x00000030
+DATA 4, MX6_IOM_DRAM_RESET,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDBA2,	0x00000000
+DATA 4, MX6_IOM_DRAM_SDODT0,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDODT1,	0x00000030
+DATA 4, MX6_IOM_GRP_CTLDS,	0x00000030
+DATA 4, MX6_IOM_DDRMODE_CTL,	0x00020000
+DATA 4, MX6_IOM_DRAM_SDQS0,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS1,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS2,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS3,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS4,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS5,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS6,	0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS7,	0x00000030
+DATA 4, MX6_IOM_GRP_DDRMODE,	0x00020000
+DATA 4, MX6_IOM_GRP_B0DS,	0x00000030
+DATA 4, MX6_IOM_GRP_B1DS,	0x00000030
+DATA 4, MX6_IOM_GRP_B2DS,	0x00000030
+DATA 4, MX6_IOM_GRP_B3DS,	0x00000030
+DATA 4, MX6_IOM_GRP_B4DS,	0x00000030
+DATA 4, MX6_IOM_GRP_B5DS,	0x00000030
+DATA 4, MX6_IOM_GRP_B6DS,	0x00000030
+DATA 4, MX6_IOM_GRP_B7DS,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM0,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM1,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM2,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM3,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM4,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM5,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM6,	0x00000030
+DATA 4, MX6_IOM_DRAM_DQM7,	0x00000030
+
+/* Calibrations */
+/* ZQ */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL,  0xa1390003
+/* write leveling */
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x001F001F
+/* Read DQS Gating calibration */
+DATA 4, MX6_MMDC_P0_MPDGCTRL0,	0x45380544
+DATA 4, MX6_MMDC_P0_MPDGCTRL1,	0x05280530
+DATA 4, MX6_MMDC_P1_MPDGCTRL0,	0x4530053C
+DATA 4, MX6_MMDC_P1_MPDGCTRL1,	0x0530050C
+/* Read calibration */
+DATA 4, MX6_MMDC_P0_MPRDDLCTL,	0x36303032
+DATA 4, MX6_MMDC_P1_MPRDDLCTL,	0x38363042
+/* Write calibration */
+DATA 4, MX6_MMDC_P0_MPWRDLCTL,	0x3A3A423E
+DATA 4, MX6_MMDC_P1_MPWRDLCTL,	0x4A38483E
+/* read data bit delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4, MX6_MMDC_P0_MPMUR0,	0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0,	0x00000800
+
+/* MMDC init */
+DATA 4, MX6_MMDC_P0_MDPDC,	0x00020036
+DATA 4, MX6_MMDC_P0_MDOTC,	0x09444040
+DATA 4, MX6_MMDC_P0_MDCFG0,	0x8A8F79A4
+DATA 4, MX6_MMDC_P0_MDCFG1,	0xDB538E64
+DATA 4, MX6_MMDC_P0_MDCFG2,	0x01ff00db
+DATA 4, MX6_MMDC_P0_MDMISC,	0x00001740
+DATA 4, MX6_MMDC_P0_MDSCR,	0x00008000
+DATA 4, MX6_MMDC_P0_MDRWD,	0x000026d2
+DATA 4, MX6_MMDC_P0_MDOR,	0x008F1023
+DATA 4, MX6_MMDC_P0_MDASP,	0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL,	0x841a0000
+
+/* Initialize Micron MT41J128M */
+DATA 4, MX6_MMDC_P0_MDSCR,	0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR,	0x0408803a
+DATA 4, MX6_MMDC_P0_MDSCR,	0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR,	0x0000803b
+DATA 4, MX6_MMDC_P0_MDSCR,	0x00408031
+DATA 4, MX6_MMDC_P0_MDSCR,	0x00408039
+DATA 4, MX6_MMDC_P0_MDSCR,	0x09408030
+DATA 4, MX6_MMDC_P0_MDSCR,	0x09408038
+DATA 4, MX6_MMDC_P0_MDSCR,	0x04008040
+DATA 4, MX6_MMDC_P0_MDSCR,	0x04008048
+DATA 4, MX6_MMDC_P0_MDREF,	0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL,	0x00011117
+DATA 4, MX6_MMDC_P1_MPODTCTRL,	0x00011117
+DATA 4, MX6_MMDC_P0_MDPDC,	0x00025576
+DATA 4, MX6_MMDC_P0_MAPSR,	0x00011006
+DATA 4, MX6_MMDC_P0_MDSCR,	0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, CCM_CCGR0, 0x00C03F3F
+DATA 4, CCM_CCGR1, 0x0030FC03
+DATA 4, CCM_CCGR2, 0x0FFFC000
+DATA 4, CCM_CCGR3, 0x3FF00000
+DATA 4, CCM_CCGR4, 0x00FFF300
+DATA 4, CCM_CCGR5, 0x0F0000C3
+DATA 4, CCM_CCGR6, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
+DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  1	   --> CKO1 enabled
+ * cko1_div 111  --> divide by 8
+ * cko1_sel 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 132/8 16.5 MHz
+ */
+DATA 4, CCM_CCOSR, 0x000000fb
diff --git a/board/advantech/dms-ba16/dms-ba16.c b/board/advantech/dms-ba16/dms-ba16.c
new file mode 100644
index 0000000..ff617ad
--- /dev/null
+++ b/board/advantech/dms-ba16/dms-ba16.c
@@ -0,0 +1,571 @@
+/*
+ * Copyright 2016 Timesys Corporation
+ * Copyright 2016 Advantech Corporation
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <pwm.h>
+DECLARE_GLOBAL_DATA_PTR;
+
+#define NC_PAD_CTRL (PAD_CTL_PUS_100K_UP |	\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |	\
+	PAD_CTL_HYS)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |	\
+	PAD_CTL_SPEED_HIGH | PAD_CTL_DSE_48ohm | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		      PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+int dram_init(void)
+{
+	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart3_pads[] = {
+	MX6_PAD_EIM_D31__UART3_RTS_B | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_EIM_D23__UART3_CTS_B | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_EIM_D24__UART3_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_EIM_D25__UART3_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart4_pads[] = {
+	MX6_PAD_KEY_COL0__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_KEY_ROW0__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	MX6_PAD_ENET_MDIO__ENET_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK  | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_RGMII_RXC__RGMII_RXC | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__RGMII_RD0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__RGMII_RD1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__RGMII_RD2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__RGMII_RD3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	/* AR8033 PHY Reset */
+	MX6_PAD_ENET_TX_EN__GPIO1_IO28 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+
+	/* Reset AR8033 PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 28), 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 28), 1);
+}
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__SD2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__SD2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT0__SD2_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT1__SD2_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT2__SD2_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT3__SD2_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_GPIO_4__GPIO1_IO04	| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_RST__SD3_RESET | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_CS0__GPIO6_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_NANDF_CS1__GPIO6_IO14 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_EB2__GPIO2_IO30 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_CSI0_DAT9__I2C1_SCL | I2C_PAD,
+		.gpio_mode = MX6_PAD_CSI0_DAT9__GPIO5_IO27 | I2C_PAD,
+		.gp = IMX_GPIO_NR(5, 27)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_CSI0_DAT8__I2C1_SDA | I2C_PAD,
+		.gpio_mode = MX6_PAD_CSI0_DAT8__GPIO5_IO26 | I2C_PAD,
+		.gp = IMX_GPIO_NR(5, 26)
+	}
+};
+
+static struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_KEY_COL3__I2C2_SCL | I2C_PAD,
+		.gpio_mode = MX6_PAD_KEY_COL3__GPIO4_IO12 | I2C_PAD,
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | I2C_PAD,
+		.gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | I2C_PAD,
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+static struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO_3__I2C3_SCL | I2C_PAD,
+		.gpio_mode = MX6_PAD_GPIO_3__GPIO1_IO03 | I2C_PAD,
+		.gp = IMX_GPIO_NR(1, 3)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO_6__I2C3_SDA | I2C_PAD,
+		.gpio_mode = MX6_PAD_GPIO_6__GPIO1_IO06 | I2C_PAD,
+		.gp = IMX_GPIO_NR(1, 6)
+	}
+};
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(2, 30)) : -1;
+}
+
+static void setup_spi(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+}
+#endif
+
+static iomux_v3_cfg_t const pcie_pads[] = {
+	MX6_PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO_17__GPIO7_IO12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_pcie(void)
+{
+	imx_iomux_v3_setup_multiple_pads(pcie_pads, ARRAY_SIZE(pcie_pads));
+}
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart3_pads, ARRAY_SIZE(uart3_pads));
+	imx_iomux_v3_setup_multiple_pads(uart4_pads, ARRAY_SIZE(uart4_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(1, 4)
+#define USDHC4_CD_GPIO	IMX_GPIO_NR(6, 11)
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1; /* eMMC is always present */
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = !gpio_get_value(USDHC4_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			gpio_direction_input(USDHC4_CD_GPIO);
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers\n"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	/* Configure AR8033 to ouput a 125MHz clk from CLK_25M */
+	/* set device address 0x7 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	/* offset 0x8016: CLK_25M Clock Select */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	/* enable register write, no post increment, address 0x7 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+	/* set to 125 MHz from local PLL source */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x18);
+
+	/* rgmii tx clock delay enable */
+	/* set debug port address: SerDes Test and System Mode Control */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	/* enable rgmii tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+static iomux_v3_cfg_t const backlight_pads[] = {
+	/* Power for LVDS Display */
+	MX6_PAD_EIM_D22__GPIO3_IO22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define LVDS_POWER_GP IMX_GPIO_NR(3, 22)
+	/* Backlight enable for LVDS display */
+	MX6_PAD_GPIO_0__GPIO1_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define LVDS_BACKLIGHT_GP IMX_GPIO_NR(1, 0)
+	/* backlight PWM brightness control */
+	MX6_PAD_SD1_DAT3__PWM1_OUT | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	imx_enable_hdmi_phy();
+}
+
+int board_cfb_skip(void)
+{
+	gpio_direction_output(LVDS_POWER_GP, 1);
+
+	return 0;
+}
+
+static int detect_baseboard(struct display_info_t const *dev)
+{
+	return 0 == dev->addr;
+}
+
+struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_baseboard,
+	.enable	= NULL,
+	.mode	= {
+		.name           = "SHARP-LQ156M1LG21",
+		.refresh        = 60,
+		.xres           = 1920,
+		.yres           = 1080,
+		.pixclock       = 7851,
+		.left_margin    = 100,
+		.right_margin   = 40,
+		.upper_margin   = 30,
+		.lower_margin   = 3,
+		.hsync_len      = 10,
+		.vsync_len      = 2,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 3,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_hdmi,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	clrbits_le32(&mxc_ccm->cscmr2, MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV);
+
+	imx_setup_hdmi();
+
+	/* Set LDB_DI0 as clock source for IPU_DI0 */
+	clrsetbits_le32(&mxc_ccm->chsccdr,
+			MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_MASK,
+			(CHSCCDR_CLK_SEL_LDB_DI0 <<
+			 MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET));
+
+	/* Turn on IPU LDB DI0 clocks */
+	setbits_le32(&mxc_ccm->CCGR3, MXC_CCM_CCGR3_LDB_DI0_MASK);
+
+	enable_ipu_clock();
+
+	writel(IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES |
+	       IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_HIGH |
+	       IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW |
+	       IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG |
+	       IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT |
+	       IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG |
+	       IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT |
+	       IOMUXC_GPR2_SPLIT_MODE_EN_MASK |
+	       IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0 |
+	       IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0,
+	       &iomux->gpr[2]);
+
+	clrsetbits_le32(&iomux->gpr[3],
+			IOMUXC_GPR3_LVDS0_MUX_CTL_MASK |
+			IOMUXC_GPR3_LVDS1_MUX_CTL_MASK |
+			IOMUXC_GPR3_HDMI_MUX_CTL_MASK,
+		       (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
+			IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET));
+
+	/* backlights off until needed */
+	imx_iomux_v3_setup_multiple_pads(backlight_pads,
+					 ARRAY_SIZE(backlight_pads));
+
+	gpio_direction_input(LVDS_POWER_GP);
+	gpio_direction_input(LVDS_BACKLIGHT_GP);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	setup_pcie();
+
+	return cpu_eth_init(bis);
+}
+
+static iomux_v3_cfg_t const misc_pads[] = {
+	MX6_PAD_KEY_ROW2__GPIO4_IO11	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EIM_A25__GPIO5_IO02	| MUX_PAD_CTRL(NC_PAD_CTRL),
+	MX6_PAD_EIM_CS0__GPIO2_IO23	| MUX_PAD_CTRL(NC_PAD_CTRL),
+	MX6_PAD_EIM_CS1__GPIO2_IO24	| MUX_PAD_CTRL(NC_PAD_CTRL),
+	MX6_PAD_EIM_OE__GPIO2_IO25	| MUX_PAD_CTRL(NC_PAD_CTRL),
+	MX6_PAD_EIM_BCLK__GPIO6_IO31	| MUX_PAD_CTRL(NC_PAD_CTRL),
+	MX6_PAD_GPIO_1__GPIO1_IO01	| MUX_PAD_CTRL(NC_PAD_CTRL),
+};
+#define SUS_S3_OUT	IMX_GPIO_NR(4, 11)
+#define WIFI_EN	IMX_GPIO_NR(6, 14)
+
+int setup_ba16_sata(void)
+{
+	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int ret;
+
+	ret = enable_sata_clock();
+	if (ret)
+		return ret;
+
+	clrsetbits_le32(&iomuxc_regs->gpr[13],
+			IOMUXC_GPR13_SATA_MASK,
+			IOMUXC_GPR13_SATA_PHY_8_RXEQ_3P0DB
+			|IOMUXC_GPR13_SATA_PHY_7_SATA2M
+			|IOMUXC_GPR13_SATA_SPEED_3G
+			|(1<<IOMUXC_GPR13_SATA_PHY_6_SHIFT)
+			|IOMUXC_GPR13_SATA_SATA_PHY_5_SS_DISABLED
+			|IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_12_16
+			|IOMUXC_GPR13_SATA_PHY_3_TXBOOST_3P33_DB
+			|IOMUXC_GPR13_SATA_PHY_2_TX_1P133V
+			|IOMUXC_GPR13_SATA_PHY_1_SLOW);
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	imx_iomux_v3_setup_multiple_pads(misc_pads,
+					 ARRAY_SIZE(misc_pads));
+
+	setup_iomux_uart();
+
+#if defined(CONFIG_VIDEO_IPUV3)
+	/* Set LDB clock to PLL2 PFD0 */
+	select_ldb_di_clock_source(MXC_PLL2_PFD0_CLK);
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	gpio_direction_output(SUS_S3_OUT, 1);
+	gpio_direction_output(WIFI_EN, 1);
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_MXC_SPI
+	setup_spi();
+#endif
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+	setup_i2c(3, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd2",	 MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+	/* We need at least 200ms between power on and backlight on
+	 * as per specifications from CHI MEI */
+	mdelay(250);
+
+	/* enable backlight PWM 1 */
+	pwm_init(0, 0, 0);
+
+	/* duty cycle 5000000ns, period: 5000000ns */
+	pwm_config(0, 5000000, 5000000);
+
+	/* Backlight Power */
+	gpio_direction_output(LVDS_BACKLIGHT_GP, 1);
+
+	pwm_enable(0);
+
+#ifdef CONFIG_CMD_SATA
+	setup_ba16_sata();
+#endif
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("BOARD: %s\n", CONFIG_BOARD_NAME);
+	return 0;
+}
diff --git a/configs/dms-ba16-1g_defconfig b/configs/dms-ba16-1g_defconfig
new file mode 100644
index 0000000..f9d227a
--- /dev/null
+++ b/configs/dms-ba16-1g_defconfig
@@ -0,0 +1,27 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_ADVANTECH_DMS_BA16=y
+CONFIG_SYS_DDR_1G=y
+CONFIG_HUSH_PARSER=y
+CONFIG_BOOTDELAY=1
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_OF_LIBFDT=y
diff --git a/configs/dms-ba16_defconfig b/configs/dms-ba16_defconfig
new file mode 100644
index 0000000..541f47a
--- /dev/null
+++ b/configs/dms-ba16_defconfig
@@ -0,0 +1,26 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_ADVANTECH_DMS_BA16=y
+CONFIG_HUSH_PARSER=y
+CONFIG_BOOTDELAY=1
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_OF_LIBFDT=y
diff --git a/include/configs/advantech_dms-ba16.h b/include/configs/advantech_dms-ba16.h
new file mode 100644
index 0000000..900e707
--- /dev/null
+++ b/include/configs/advantech_dms-ba16.h
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2016 Timesys Corporation
+ * Copyright (C) 2016 Advantech Corporation
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ADVANTECH_DMSBA16_CONFIG_H
+#define __ADVANTECH_DMSBA16_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_BOARD_NAME	"Advantech DMS-BA16"
+#define CONFIG_DEFAULT_FDT_FILE	"imx6q-dms-ba16.dtb"
+
+#define CONFIG_MXC_UART_BASE	UART4_BASE
+#define CONFIG_CONSOLE_DEV	"ttymxc3"
+#define CONFIG_EXTRA_BOOTARGS	"panic=10"
+
+#define CONFIG_BOOT_DIR	""
+#define CONFIG_LOADCMD "fatload"
+#define CONFIG_RFSPART "2"
+
+#ifdef CONFIG_SYS_DDR_1G
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#else
+#define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
+#endif
+
+#define CONFIG_SUPPORT_EMMC_BOOT
+
+#include "mx6_common.h"
+#include <linux/sizes.h>
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_GPIO
+#define CONFIG_MXC_UART
+
+#define CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+
+/* SATA Configs */
+#define CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_DOS_PARTITION
+
+/* USB Configs */
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS	0
+#define CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+#define CONFIG_USB_GADGET
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
+#define CONFIG_G_DNL_VENDOR_NUM   0x0525
+#define CONFIG_G_DNL_PRODUCT_NUM  0xa4a5
+#define CONFIG_G_DNL_MANUFACTURER "Advantech"
+
+/* Networking Configs */
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME		"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		4
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+/* Serial Flash */
+#ifdef CONFIG_CMD_SF
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		0
+#define CONFIG_SF_DEFAULT_SPEED	20000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_BAUDRATE	115200
+
+/* Command definition */
+#define CONFIG_CMD_BMODE
+
+#define CONFIG_LOADADDR	0x12000000
+#define CONFIG_SYS_TEXT_BASE	0x17800000
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"image=" CONFIG_BOOT_DIR "/uImage\0" \
+	"uboot=u-boot.imx\0" \
+	"fdt_file=" CONFIG_BOOT_DIR "/" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=yes\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONFIG_CONSOLE_DEV "\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+	"sddev=0\0" \
+	"emmcdev=1\0" \
+	"partnum=1\0" \
+	"loadcmd=" CONFIG_LOADCMD "\0" \
+	"rfspart=" CONFIG_RFSPART "\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "	\
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0" \
+	"update_sf_uboot=" \
+		"if tftp $loadaddr $uboot; then " \
+			"sf probe; " \
+			"sf erase 0 0xC0000; " \
+			"sf write $loadaddr 0x400 $filesize; " \
+			"echo 'U-Boot upgraded. Please reset'; " \
+		"fi\0" \
+	"setargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/${rootdev} rw rootwait " CONFIG_EXTRA_BOOTARGS "\0" \
+	"loadbootscript=" \
+		"${loadcmd} ${dev} ${devnum}:${partnum} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from ${dev}:${devnum}:${partnum};" \
+		" source\0" \
+	"loadimage=" \
+		"${loadcmd} ${dev} ${devnum}:${partnum} ${loadaddr} ${image}\0" \
+	"loadfdt=${loadcmd} ${dev} ${devnum}:${partnum} ${fdt_addr} ${fdt_file}\0" \
+	"tryboot=" \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loadimage; then " \
+				"run doboot; " \
+			"fi; " \
+		"fi;\0" \
+	"doboot=echo Booting from ${dev}:${devnum}:${partnum} ...; " \
+		"run setargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootm; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootm; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootm; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootm; " \
+		"fi;\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"usb start; " \
+	"setenv dev usb; " \
+	"setenv devnum 0; " \
+	"setenv rootdev sda${rfspart}; " \
+	"run tryboot; " \
+	\
+	"setenv dev mmc; " \
+	"setenv rootdev mmcblk0p${rfspart}; " \
+	\
+	"setenv devnum ${sddev}; " \
+	"if mmc dev ${devnum}; then " \
+		"run tryboot; " \
+		"setenv rootdev mmcblk1p${rfspart}; " \
+	"fi; " \
+	\
+	"setenv devnum ${emmcdev}; " \
+	"if mmc dev ${devnum}; then " \
+		"run tryboot; " \
+	"fi; " \
+	\
+	"bmode usb; " \
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE               (128 * 1024)
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE		(8 * 1024)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#endif
+
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+
+/* Framebuffer */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IPUV3_CLK 260000000
+#define CONFIG_IMX_HDMI
+#define CONFIG_IMX_VIDEO_SKIP
+
+#define CONFIG_PWM_IMX
+#define CONFIG_IMX6_PWM_PER_CLK	66000000
+
+#undef CONFIG_CMD_PCI
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(7, 12)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(1, 5)
+#endif
+
+/* I2C Configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		  100000
+#define CONFIG_SYS_I2C_MXC_I2C1
+#define CONFIG_SYS_I2C_MXC_I2C2
+#define CONFIG_SYS_I2C_MXC_I2C3
+
+#endif	/* __ADVANTECH_DMSBA16_CONFIG_H */
-- 
2.8.1

